use std::{
  fs::{self, File},
  mem,
  ops::DerefMut,
  path::PathBuf,
  process::Stdio,
  sync::{Arc, Mutex},
  time::Duration,
};

use anyhow::{Result, anyhow, bail};
use tokio::{
  io::{AsyncReadExt, BufReader},
  net::{UnixListener, UnixStream, unix::OwnedWriteHalf},
  sync::oneshot::{Receiver, Sender},
  time::{sleep, timeout},
};

use crate::{
  log::Log,
  modmap::{ExtModuleMap, IntegralFnId, IntegralModId, NumFunUid},
  shmem_capture::{MetadataPublisher, TestParams, hooklib_commons::*, send_test_metadata},
  stages::{arg_capture::PacketReader, common::*},
};

use super::arg_capture::PacketProvider;

/// returns the path to the socket used to communicate with test instances
/// (e.g. supply function argument values, communicate start/end of a test session)
pub fn test_server_socket() -> String {
  null_terminated_to_string(TEST_SERVER_SOCKET_NAME)
    .expect("Failed to convert null-terminated socket name")
}

/// this functions takes care of spawning the central "dispatch" server
/// to which all test instances connect
///
/// this future signals readiness (listening for connections) via ready_tx
/// and periodically checks end_rx (orders the future (and the server) to terminate)
pub async fn test_server_job(
  packet_dir: PathBuf,
  modules: Arc<ExtModuleMap>,
  mem_limit: usize,
  (ready_tx, mut end_rx): (Sender<()>, Receiver<()>),
  results: Arc<Mutex<TestResults>>,
) -> Result<()> {
  let lg = Log::get("test_server_job");
  let path = test_server_socket();
  lg.info(format!("Starting at {path}"));
  let listener = UnixListener::bind(path.clone())?;
  ready_tx.send(()).map_err(|_| anyhow!("Receiver dropped"))?;
  lg.info("Listening");

  let mut handles = vec![];

  while end_rx.try_recv().is_err() {
    match timeout(Duration::from_millis(100), listener.accept()).await {
      Ok(Ok((client_stream, client_addr))) => {
        lg.trace(format!("Connected test {client_addr:?}"));
        let results = results.clone();
        handles.push(tokio::spawn(single_test_job(
          client_stream,
          packet_dir.to_path_buf(),
          modules.clone(),
          mem_limit,
          results,
        )));
      }
      Ok(Err(e)) => Err(anyhow!(e))?,
      Err(_) => continue,
    }
  }
  lg.info("Finishing");
  for handle in handles {
    if let Err(e) = handle.await? {
      lg.crit(format!("A job has finished with error: {e}"));
    }
  }
  mem::drop(listener);
  fs::remove_file(path)?;
  Ok(())
}

#[derive(Debug, Clone, Copy)]
pub struct CallIndexT(pub u32);
#[derive(Debug, Clone, Copy)]
pub struct PacketIndexT(pub u64);
#[derive(Debug, Clone, Copy)]
/// message received from the test client (test coordinator)
enum TestMessage {
  /// test started
  Start(IntegralModId, IntegralFnId, CallIndexT),
  /// test requested argument packet (payload is the packet index)
  PacketRequest(PacketIndexT),
  /// test (testing a packet index) ended with a status
  TestEnd(PacketIndexT, TestStatus),
  /// entire test session ended
  End,
}

#[derive(Debug, Clone, Copy)]
pub enum TestStatus {
  Timeout,
  #[allow(dead_code)] // used by Debug
  Exit(i32),
  #[allow(dead_code)]
  Signal(i32),
  /// an unexpected test failure outside the sandboxing and monitoring of the test coordinator
  /// - could be a test coordinator crash
  Fatal,
}

pub type TestResults = Vec<(
  IntegralModId,
  IntegralFnId,
  CallIndexT,
  PacketIndexT,
  TestStatus,
)>;

// note: TAG_* constants are common for the hook library and llcap-server (generated by bindgen)

impl TryFrom<&[u8]> for TestStatus {
  type Error = String;

  /// format of [`TestStatus`] messages:
  ///
  /// `| TAG: 2B | payload: 0-4B |`
  ///
  /// payload is either empty for [`Timeout`][`TestStatus::Timeout`] and [`Fatal`][`TestStatus::Fatal`] variants
  /// or and 4B of [`i32`] representing either the test's
  /// [`Signal`][`TestStatus::Signal`] or [`Exit`][`TestStatus::Exit`] code
  fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
    let (tag, data) = value.split_at(2);
    if tag.starts_with(&TAG_TIMEOUT.to_le_bytes()) {
      Ok(Self::Timeout)
    } else if tag.starts_with(&TAG_EXIT.to_le_bytes()) {
      let sized: [u8; 4] = data
        .try_into()
        .map_err(|e: std::array::TryFromSliceError| e.to_string())?;
      Ok(Self::Exit(i32::from_le_bytes(sized)))
    } else if tag.starts_with(&TAG_SGNL.to_le_bytes()) {
      let sized: [u8; 4] = data
        .try_into()
        .map_err(|e: std::array::TryFromSliceError| e.to_string())?;
      Ok(Self::Signal(i32::from_le_bytes(sized)))
    } else if tag.starts_with(&TAG_FATAL.to_le_bytes()) {
      Ok(Self::Fatal)
    } else {
      Err(format!("Invalid status format: {value:?}"))
    }
  }
}

/// extracts the first 4 bytes into a u32 from a starting offset
pub fn consume_to_u32(bytes: &[u8], start: usize) -> Result<u32, String> {
  if bytes.len() < start + 4 {
    return Err("Not enough bytes".to_string());
  }
  let le_bytes = [
    *bytes.get(start).unwrap(),
    *bytes.get(start + 1).unwrap(),
    *bytes.get(start + 2).unwrap(),
    *bytes.get(start + 3).unwrap(),
  ];
  let num = u32::from_le_bytes(le_bytes);
  Ok(num)
}

// note: TAG_* constants are common for the hook library and llcap-server (generated by bindgen)

impl TryFrom<&[u8]> for TestMessage {
  type Error = String;

  /// format of test messages
  ///
  /// `| TAG: 2B | payload: 0-14B |`
  ///
  /// payload is empty for ([`End`][`TestMessage::End`])
  /// or consists of 2x4B IDs for ([`Start`][`TestMessage::Start`])
  /// or ([`PacketRequest`][`TestMessage::PacketRequest`]) 8B of the packet index
  /// or ([`TestEnd`][`TestMessage::TestEnd`]) 8B of the packet index + (2 - 6B) representing a [`TestStatus`]
  fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
    let (tag, data) = value.split_at(2);
    if tag.starts_with(&TAG_START.to_le_bytes()) {
      Ok(Self::Start(
        IntegralModId(consume_to_u32(data, 0)?),
        IntegralFnId(consume_to_u32(data, 4)?),
        CallIndexT(consume_to_u32(data, 8)?),
      ))
    } else if tag.starts_with(&TAG_PKT.to_le_bytes()) {
      let pkt_idx_bytes: [u8; 8] = data
        .split_at(8)
        .0
        .try_into()
        .map_err(|e: std::array::TryFromSliceError| e.to_string() + " pktrq")?;
      Ok(Self::PacketRequest(PacketIndexT(u64::from_le_bytes(
        pkt_idx_bytes,
      ))))
    } else if tag.starts_with(&TAG_TEST_END.to_le_bytes()) {
      let (s1, s2) = data.split_at(8);
      let pkt_idx_bytes: [u8; 8] = s1
        .try_into()
        .map_err(|e: std::array::TryFromSliceError| e.to_string() + " msgend")?;
      Ok(Self::TestEnd(
        PacketIndexT(u64::from_le_bytes(pkt_idx_bytes)),
        TestStatus::try_from(s2)?,
      ))
    } else if tag.starts_with(&TAG_TEST_FINISH.to_le_bytes()) {
      Ok(Self::End)
    } else {
      Err(format!("Invalid msg format: {value:?}"))
    }
  }
}

#[derive(Debug)]
/// the state of the test client handling, updates of this state are communicated by the test coordinator
enum ClientState {
  /// test session is starting, no message other than "start" is expected
  Init,
  /// test session started, testing a particular function at a particular call index
  /// expects packet requests
  Started(IntegralModId, IntegralFnId, CallIndexT),
  /// test session has ended, no more messages are expected
  Ended,
}

/// this future spawns a single test job that handles communication with and monitoring
/// of a single test session (function id + call index)
///
/// during the test session, the target application is executed N times, once for each recorded
/// argument tuple, this client job supplies a different tuple on each execution (based on the requests it receives)
async fn single_test_job(
  stream: UnixStream,
  packet_dir: PathBuf,
  modules: Arc<ExtModuleMap>,
  mem_limit: usize,
  results: Arc<Mutex<TestResults>>,
) -> Result<()> {
  // TODO: report test failures in "results" (see return statements - failure is only logged)

  // initialize state, packet supply and the stream for reading and writing to the client on the other side
  let mut state = ClientState::Init;
  let mut lg = Log::get(&format!("single_test_job@{state:?}"));
  let mut packets = PacketReader::new(&packet_dir, &modules, mem_limit)?;
  let (read, mut write) = stream.into_split();
  let mut buff_stream = BufReader::new(read);

  loop {
    // preallocate 16bytes for client messages
    let mut data = [0u8; 16];
    // polling with timeout to check for client status updates
    match timeout(Duration::from_millis(100), buff_stream.read(&mut data)).await {
      Ok(Ok(0)) => {
        bail!("Client closed connection - ending, state: {:?}", state);
      }
      Ok(Ok(n)) => {
        if n != data.len() {
          bail!(
            "Expected {} bytes, got {n} - ending, state: {:?}",
            data.len(),
            state
          );
        }
        // we received a message, we continue to message handling
      }
      Ok(Err(e)) => {
        bail!("Not readable {e} - ending, state: {:?}", state);
      }
      Err(_) => continue, // timeout
    }

    lg.trace(format!("Read done: {data:?}"));
    let msg = TestMessage::try_from(data.as_slice()).map_err(|e| anyhow!(e))?;

    let (new_state, response) =
      handle_client_msg(state, msg, &mut packets, results.clone()).map_err(|e| anyhow!(e))?;
    state = new_state;
    lg = Log::get(&format!("single_test_job@{state:?}")); // rename logger for a new state
    if matches!(state, ClientState::Ended) {
      lg.trace("Client ended");
      return Ok(());
    }

    lg.trace(format!("Response: {response:?}"));
    if response.is_none() {
      continue; // no response required
    }

    send_protocol_response(&mut write, &response.unwrap()).await?;
  }
}

/// Ok variant contains a new client state and an optional response - if none, no response
/// shall be sent
///
/// implements a simple state machine (states via [`ClientState`], messages via [`TestMessage`]):
///
/// ```
///                                     v----EndTest/PacketRequest----+
/// | Init | ----- Start/End ----> | Started | -----------------------+----End----> | Ended |
///
/// ```
/// all other transitions are considered an error
fn handle_client_msg(
  state: ClientState,
  msg: TestMessage,
  packets: &mut dyn PacketProvider,
  results: Arc<Mutex<TestResults>>,
) -> Result<(ClientState, Option<Vec<u8>>), String> {
  match state {
    ClientState::Init => match msg {
      TestMessage::Start(m, f, i) => Ok((ClientState::Started(m, f, i), None)),
      TestMessage::End => Ok((ClientState::Ended, None)),
      _ => Err(format!(
        "Invalid transition from Init state with msg {msg:?}"
      )),
    },
    ClientState::Started(mod_id, fn_id, call_idx) => match msg {
      TestMessage::TestEnd(test_index, status) => {
        Log::get("handle_client_msg").info(format!(
          "test {} {} ended: {status:?}, idx: {}",
          mod_id.hex_string(),
          fn_id.hex_string(),
          test_index.0
        ));
        results
          .lock()
          .unwrap()
          .push((mod_id, fn_id, call_idx, test_index, status));
        Ok((state, None))
      }
      TestMessage::PacketRequest(idx) => {
        let response = packets.get_packet(mod_id, fn_id, idx.0 as usize);
        Ok((state, response))
      }
      TestMessage::End => Ok((ClientState::Ended, None)),
      _ => Err(format!(
        "Invalid transition from Started state with msg {msg:?}"
      )),
    },
    ClientState::Ended => Err(format!(
      "Client state is Ended, no more messages were expected msg: {msg:?}, from state: {state:?}"
    )),
  }
}

async fn raw_send_to_client(stream: &mut OwnedWriteHalf, data: &[u8]) -> Result<()> {
  let mut idx = 0;
  loop {
    stream.writable().await?;
    // not expecting too much contention/throughput, busy looping seems okay
    match stream.try_write(data.split_at(idx).1) {
      Ok(n) => {
        if n == data.len() {
          return Ok(());
        }
        idx += n;
        continue;
      }
      Err(ref e) if e.kind() == tokio::io::ErrorKind::WouldBlock => {
        continue;
      }
      Err(e) => {
        bail!(e.to_string());
      }
    }
  }
}

/// sends response in accordance with the comms protocol between the test client and this server
async fn send_protocol_response(write_stream: &mut OwnedWriteHalf, response: &[u8]) -> Result<()> {
  // send response length + response
  raw_send_to_client(
    write_stream,
    &(response.as_ref().len() as u32).to_le_bytes(),
  )
  .await?;

  raw_send_to_client(write_stream, response).await
}

pub async fn test_job(
  metadata_svr: Arc<Mutex<MetadataPublisher>>,
  infra_params: InfraParams,
  fn_uid: NumFunUid,
  arg_count: u32,
  test_count: u32,
  command: Arc<Vec<String>>,
  output_gen: Arc<Option<TestOutputPathGen>>,
) -> Result<()> {
  let (m, f) = (fn_uid.module_id, fn_uid.function_id);
  // let mut tests = vec![];
  for call_idx in 0..test_count {
    {
      let mut guard = metadata_svr.lock().unwrap();
      send_test_metadata(
        guard.deref_mut(),
        infra_params,
        NumFunUid {
          function_id: f,
          module_id: m,
        },
        TestParams {
          arg_count,
          test_count,
          target_call_number: call_idx + 2,
        },
      )?;
    }
    let mut cmd = cmd_from_args(&command)?;
    if let Some(output_gen) = output_gen.as_ref() {
      let out_path = output_gen.get_out_path(m, f, call_idx + 1);
      let err_path = output_gen.get_err_path(m, f, call_idx + 1);
      cmd.stdout(Stdio::from(File::create(out_path.clone()).map_err(
        |e| anyhow!(e).context(format!("Stdout file creation failed: {out_path:?}")),
      )?));
      cmd.stderr(Stdio::from(File::create(err_path).map_err(|e| {
        anyhow!(e).context(format!("Stderr file creation failed {out_path:?}"))
      })?));
    }
    let mut test = cmd
      .spawn()
      .map_err(|e| anyhow!(e).context("spawn from command"))?;

    let _ = test.wait();
    // TODO decide:
    // fully parallel test execution VS costs of seeking/re-reading packet capture files
    // when two non-subsequent packets are requested
    // for parallel impl, uncomment the below and the 1st line in this fn
    //    tests.push(test);
  }
  // while !tests.iter_mut().all(|t| t.try_wait().is_ok()) {
  //   sleep(Duration::from_millis(300)).await;
  // }
  // additional sleep here to ensure that server processes all the incoming "test end" messages
  // before we "kill" it
  sleep(Duration::from_millis(300)).await;
  Ok(())
}

pub struct TestOutputPathGen {
  dir: bool,
  base: PathBuf,
}

impl TestOutputPathGen {
  pub fn new(base: Option<PathBuf>) -> Option<Self> {
    if let Some(base) = base {
      Self {
        dir: base.clone().is_dir(),
        base,
      }
      .into()
    } else {
      None
    }
  }

  pub fn get_out_path(&self, m: IntegralModId, f: IntegralFnId, id: u32) -> PathBuf {
    self.get_path(format!(
      "M{}-F{}-{}.out",
      m.hex_string(),
      f.hex_string(),
      id
    ))
  }

  pub fn get_err_path(&self, m: IntegralModId, f: IntegralFnId, id: u32) -> PathBuf {
    self.get_path(format!(
      "M{}-F{}-{}.err",
      m.hex_string(),
      f.hex_string(),
      id
    ))
  }

  fn get_path(&self, dir_append_variant: String) -> PathBuf {
    if self.dir {
      self.base.join(dir_append_variant)
    } else {
      self.base.clone()
    }
  }
}

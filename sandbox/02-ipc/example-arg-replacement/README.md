# Argument replacement example

This is a simple demo that aims to demonstrate the capabilities of the `llcap` tooling, specifically the ability to record called functions, their arguments and to replace the arguments with the recorded ones.

## Prerequisites

* LLVM-based tooling (AST plugin as well as the LLVM plugin) built and installed
* [llcap-server](../llcap-server/) built (or at least `cargo` toolchain installed)

## Workflow

We will divide the functionality we demo here into two parts: argument replacement of *primitive* types that is visible on program exit code and argument replacement of *custom* (more dynamic) types observable in the standard output.

The workflow consists of 3 steps: **call tracing**, **argument capture**, and **testing**.


### Stage 1: Call tracing

In this stage, we will

* instrument the application for function call recording
* run `llcap-server` and the instrumented application
* select functions of interest for the argument caputre stage


First, run 

    ./build-call-trace.sh
    mv ./arg-replacement ./arg-replacement-tracecalls

This step generates the `module-maps` directory and compiles the exmaple binary ([main.cpp](./main.cpp)). We also move the binary to a different location to make it possible to reuse it later. (if the source doesn't change, this instrumented binary along with the `module-maps` can be reused) 

Then, navigate to the [../llcap-server](../llcap-server/) directory (`cd ../llcap-server`). Here, we will run the `llcap-server`:

> [!tip]
>  if `llcap-server` fails early during its initialization, you can use the `--cleanup` flag to perform cleanup of unreleased resources

        cargo r -- --modmap ../example-arg-replacement/module-maps/\
         trace-calls -o ./selected-fns.bin\
         ../example-arg-replacement/arg-replacement-tracecalls


Or for the Podman demo:

        ./bin/llcap-server --modmap ../example-arg-replacement/module-maps/\
         trace-calls -o ./selected-fns.bin\
         ../example-arg-replacement/arg-replacement-tracecalls

> [!note]
>  in the Podman demo prebuilt container, you should replace `cargo r --` with `./bin/llcap-server` 

This command:
* passes the `module-maps` directory generated by the instrumentation
* specifies that function selection will be saved in the `selected-fns.bin` file (this argument is not mandatory, if not present, user will be prompted for a path)
* the *call tracing* will be performed by executing the application via `../example-arg-replacement/arg-replacement-tracecalls` (just like running it from the command line, all the trailing arguments specify the "command")

You should see similar output, prompting you to perform selection:

```
0 - 5 - std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>> templateTest<std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>>(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char>>) (module /path/to/arg-replacement-demomain.cpp)
1 - 4 - multiply_i_f(int, float) (module /path/to/arg-replacement-demo/main.cpp)
2 - 1 - main (module /path/to/arg-replacement-demomain.cpp)
```

You should select the indicies from the first column to indicate which functions you'd like to perform testing on. For primitive type replacement, input `1` (the `multiply_i_f` function), for *custom* type replacement, input `0` (the demonic-looking function). Next, press enter. The (important) result of this stage will be saved in the specified location (e.g. `./selected-fns.bin`).

> [!tip] Help
> for help use classic `--help` flag for top-level help (`cargo r  -- --help`) or a stage help `cargo r  -- trace-calls --help`

> [!tip] Logging verbosity
>  to turn on more verbose logging, use the aggregated `-v` flag like so (more `v`s, more logging): `cargo r  -- -vvv ...`

> [!tip] (cargo) Optimized build
> to run in "release" mode, use the `--release` cargo flag like so: `cargo r --release -- ...`


### Stage 2: Argument capture

In this stage, we will use the output generated by the previous stage for:

* anoter instrumentation pass (compilation) that adjusts the instrumentation for argument capture and the final testing stage
* arguments to the `llcap-server` 

First, compile for argument capture using the generated `selected-fns.bin` file:

    ./build-arg-trace.sh ../llcap-server/selected-fns.bin

Next, run `llcap-server`, passing the genrated files to it, as well as the command line invocation of the instrumented binary (as tail argunment pack):

    cargo r -- --modmap ../example-arg-replacement/module-maps/\
     capture-args -s ./selected-fns.bin\
     -o ./arg-traces-dir\
     ../example-arg-replacement/arg-replacement

Or for the Podman demo:

    ./bin/llcap-server --modmap ../example-arg-replacement/module-maps/\
     capture-args -s ./selected-fns.bin\
     -o ./arg-traces-dir\
     ../example-arg-replacement/arg-replacement

This command:
* combines the `module-maps` generated by our instrumentation with the `selected-fns.bin` file that specifies which functions we are targeting
* specifies the argument traces will be saved into `arg-traces-dir` directory
* the capture will be performed by executing the application via `../example-arg-replacement/arg-replacement` (just like running it from the command line)


**Alternatively**, you can prepend the command with the removal of the capture output directory as **the directory is expected not to exist** by the `llcap-server`.

    rm -rf ./arg-traces-dir && cargo r --release --\
     --modmap ../example-arg-replacement/module-maps/\
     capture-args -s ./selected-fns.bin -o ./arg-traces-dir\
     ../example-arg-replacement/arg-replacement

Or for the Podman demo:

    rm -rf ./arg-traces-dir && ./bin/llcap-server --modmap ../example-arg-replacement/module-maps/\
     capture-args -s ./selected-fns.bin\
     -o ./arg-traces-dir\
     ../example-arg-replacement/arg-replacement

After finishing, you should be able to see the `arg-traces-dir` directory. Here, recorded function arguments are encoded. Generally, the process of adjusting the target application source files will force you to run the entire process again all the way from [Stage 1](#stage-2-argument-capture).

### Stage 3: Testing

We are now ready to execute tests based on the recorded data. **No recompilation is needed for this stage**. We create output directory and run `llcap-server`:

    mkdir ./arg-trace-outputs

    cargo r --release -- --modmap ../example-arg-replacement/module-maps/\
     test -s ./selected-fns.bin -c ./arg-traces-dir\
     -o ./arg-trace-outputs/ ../example-arg-replacement/arg-replacement

Or for the Podman demo:

    mkdir ./arg-trace-outputs

    ./bin/llcap-server --modmap ../example-arg-replacement/module-maps/\
        test -s ./selected-fns.bin -c ./arg-traces-dir\
        -o ./arg-trace-outputs/ ../example-arg-replacement/arg-replacement

This command: 

* passes the generated `module-maps`, `selected-fns.bin` and `arg-traces-dir/` to the `llcap-server`
* specifies `arg-trace-outputs` as the output directory for standard output and error of the test cases
* instructs `llcap-server` to run the tests by executing `../example-arg-replacement/`

Akin to Stage 2, for quick re-testing, you can use this command which empties the created test ouput directory:

    rm -rf ./arg-trace-outputs/* && \
     cargo r --release -- --modmap ../example-arg-replacement/module-maps/\
     test -s ./selected-fns.bin -c ./arg-traces-dir\
     -o ./arg-trace-outputs/\
      ../example-arg-replacement/arg-replacement

Or for the Podman demo:

    rm -rf ./arg-trace-outputs/* && \
     ./bin/llcap-server --modmap ../example-arg-replacement/module-maps/\
     test -s ./selected-fns.bin -c ./arg-traces-dir\
     -o ./arg-trace-outputs/ ../example-arg-replacement/arg-replacement

### Interpreting results

Based on your choice of instrumented funtion selection in [Stage 1](#stage-2-argument-capture), we will focus on different parts of the output:

#### Primitive type instrumentation

In the standard output of `llcap-server` you will see a result table that reports the results
of the instrumented runs. You will see that most test cases result in the same termination status.
One triplet of resuts differs, though. The triplet is actually a quadruplet of
test cases that all replace the arguments of *the first recorded call* to the function (`multiply_i_f`):

```
I | [main] Module ID | Function ID |  Call  | Packet | Result
I | [main]  F7DB0979 |  03000000   |   1    |   0    | Exit(63)
I | [main]  F7DB0979 |  03000000   |   1    |   1    | Exit(12)
I | [main]  F7DB0979 |  03000000   |   1    |   2    | Exit(88)
I | [main]  F7DB0979 |  03000000   |   1    |   3    | Signal(11)
```

The `Call` column tells us that the first call has been instrumented.

The `Packet` column provides the index of the set of arguments that we passed as a replacement of the original arguments of that (first) call. E.g. `0` for the first set of arguments (captured from the first call of the function as recorded by [Stage 2](#stage-2-argument-capture)).

In the source code, we see that the function `multiply_i_f` is called with the 
following argument pairs: `21, 3.0f`, `3, 4.0f`, `44, 2.0f`, and `0, 0`.

We also see that if the *first* call results in zero, we "crash". Furthermore, 
only the first call determines the exit code of the application.

Following the above, we obtain the reason behind the values seen in the `Result`
column (`21 * 3.0f = 63`, `0 * 0 = 0`, crashes, etc.).

<details>
<summary>Example output of Stage 3 of primite type instrumentation</summary>

```
P | [main] Verbosity: 0
P | [main] Reading function selection
P | [main] Masking
P | [main] Setting up function packet reader
P | [main] Setting up function packet server
P | [main] Run program for fn m: C545C51D f: 00000000
P | [main] Waiting for jobs to finish...
P | [main] Waiting for server to exit...
P | [main] ---------------------------------------------------------------
P | [main] Test results (16): 
P | [main] Module ID | Function ID |  Call  | Packet | Result
P | [main]  C545C51D |  00000000   |   1    |   0    | Exit(63)
P | [main]  C545C51D |  00000000   |   1    |   1    | Exit(12)
P | [main]  C545C51D |  00000000   |   1    |   2    | Exit(88)
P | [main]  C545C51D |  00000000   |   1    |   3    | Signal(11)
P | [main]  C545C51D |  00000000   |   2    |   0    | Exit(63)
P | [main]  C545C51D |  00000000   |   2    |   1    | Exit(63)
P | [main]  C545C51D |  00000000   |   2    |   2    | Exit(63)
P | [main]  C545C51D |  00000000   |   2    |   3    | Exit(63)
P | [main]  C545C51D |  00000000   |   3    |   0    | Exit(63)
P | [main]  C545C51D |  00000000   |   3    |   1    | Exit(63)
P | [main]  C545C51D |  00000000   |   3    |   2    | Exit(63)
P | [main]  C545C51D |  00000000   |   3    |   3    | Exit(63)
P | [main]  C545C51D |  00000000   |   4    |   0    | Exit(63)
P | [main]  C545C51D |  00000000   |   4    |   1    | Exit(63)
P | [main]  C545C51D |  00000000   |   4    |   2    | Exit(63)
P | [main]  C545C51D |  00000000   |   4    |   3    | Exit(63)
P | [main] ---------------------------------------------------------------
P | [main] Exiting...
```

</details>

#### Custom type instrumentation

In this instrumentation example, we will focus on the outputs of the **test cases**.
In the `arg-trace-outputs` directory, there are files ending with `.out` and `.err` for each test case's standard output and error. We will inspect the `.out` files. First though, let's look at the source code:

```c++
std::string v("www");

for(int t = 0; t < 5; ++t){  
  v = templateTest<std::string>(v);
  // if templateTest is instrumented, the line below demonstrates argument replacement for
  // a C++ type
  std::cout << v << std::endl; 
  v += " x";
}
```

As the comment explains, we should see differences on the standard output. Suppose we replaced the first call's arguments with the canonical last call's arguments:

The last call's argument would look like `www x x x x` (the string after the 5th addition of `x` is never passed to `templateTest`). Therefore, the if we replace the firs call's argument with this value, we shall see the string being extended to up to: `www x x x x x x x x` (`x` 8 times).

This is visible in one of the output files, ending with `-1.out` (indicating that this file **aggregates the outputs of all the replacements of the first call**). Due to the aggregation of
outputs into single file, we see replacements with all available values (`www`, `www x`, `www x x`, `www x x x`, and `www x x x x`) with the last call replacement executuion at the very bottom:

```
www x x x x
www x x x x x
www x x x x x x
www x x x x x x x
www x x x x x x x x
Got 21 3.000000
Returning 63
Got 3 4.000000
Returning 12
Got 44 2.000000
Returning 88
Got 0 0.000000
Returning 0
```


<details>
<summary>Example llcap-server output of Stage 3 of "custom" (std::string) type instrumentation</summary>

```
I | [main] Verbosity: 0
I | [main] Reading function selection
I | [main] Masking
I | [main] Setting up function packet reader
I | [main] Setting up function packet server
T | [main] Server ready
I | [main] Run program for fn m: C545C51D f: 02000000
I | [main] Waiting for jobs to finish...
I | [main] Waiting for server to exit...
I | [main] ---------------------------------------------------------------
I | [main] Test results (25): 
I | [main] Module ID | Function ID |  Call  | Packet | Result
I | [main]  C545C51D |  02000000   |   1    |   0    | Exit(63)
I | [main]  C545C51D |  02000000   |   1    |   1    | Exit(63)
I | [main]  C545C51D |  02000000   |   1    |   2    | Exit(63)
I | [main]  C545C51D |  02000000   |   1    |   3    | Exit(63)
I | [main]  C545C51D |  02000000   |   1    |   4    | Exit(63)
I | [main]  C545C51D |  02000000   |   2    |   0    | Exit(63)
I | [main]  C545C51D |  02000000   |   2    |   1    | Exit(63)
I | [main]  C545C51D |  02000000   |   2    |   2    | Exit(63)
I | [main]  C545C51D |  02000000   |   2    |   3    | Exit(63)
I | [main]  C545C51D |  02000000   |   2    |   4    | Exit(63)
I | [main]  C545C51D |  02000000   |   3    |   0    | Exit(63)
I | [main]  C545C51D |  02000000   |   3    |   1    | Exit(63)
I | [main]  C545C51D |  02000000   |   3    |   2    | Exit(63)
I | [main]  C545C51D |  02000000   |   3    |   3    | Exit(63)
I | [main]  C545C51D |  02000000   |   3    |   4    | Exit(63)
I | [main]  C545C51D |  02000000   |   4    |   0    | Exit(63)
I | [main]  C545C51D |  02000000   |   4    |   1    | Exit(63)
I | [main]  C545C51D |  02000000   |   4    |   2    | Exit(63)
I | [main]  C545C51D |  02000000   |   4    |   3    | Exit(63)
I | [main]  C545C51D |  02000000   |   4    |   4    | Exit(63)
I | [main]  C545C51D |  02000000   |   5    |   0    | Exit(63)
I | [main]  C545C51D |  02000000   |   5    |   1    | Exit(63)
I | [main]  C545C51D |  02000000   |   5    |   2    | Exit(63)
I | [main]  C545C51D |  02000000   |   5    |   3    | Exit(63)
I | [main]  C545C51D |  02000000   |   5    |   4    | Exit(63)
I | [main] ---------------------------------------------------------------
T | [main] Cleaning up
I | [main] Exiting...
```

</details>

## Troubleshooting: Unhandled target program crash causes llcap-server to "hang"

*This should not happen and indicates a bug*

*Applies for [Stage 1](#stage-1-call-tracing) and [Stage 2](#stage-2-argument-capture)*

If the instrumented application crashes and `llcap-server` refuses to make progress, 
we can send manual "end message" to the `llcap-server`.

### Prerequisites

* [`ipc-finalizer`](../ipc-finalizer/) built

### Steps

In [`ipc-finalizer`](../ipc-finalizer/):

    ./ipc-fin /llcap-capture-base-semfull <number_of_buffers>

The number of buffers is also exposed by the `llcap-server` when running with the `-v` flag.

The default number of buffers can be found in [llcap-server's](../llcap-server/) `--help` message:

    cargo r --release -- --help

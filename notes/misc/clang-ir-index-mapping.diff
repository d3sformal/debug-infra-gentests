diff --git a/clang/lib/CodeGen/CodeGenFunction.cpp b/clang/lib/CodeGen/CodeGenFunction.cpp
index 4d29ceace64..275c7431045 100644
--- a/clang/lib/CodeGen/CodeGenFunction.cpp
+++ b/clang/lib/CodeGen/CodeGenFunction.cpp
@@ -11,6 +11,8 @@
 //===----------------------------------------------------------------------===//
 
 #include "CodeGenFunction.h"
+#include "ABIInfo.h"
+#include "Address.h"
 #include "CGBlocks.h"
 #include "CGCUDARuntime.h"
 #include "CGCXXABI.h"
@@ -36,6 +38,7 @@
 #include "clang/CodeGen/CGFunctionInfo.h"
 #include "clang/Frontend/FrontendDiagnostic.h"
 #include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/StringRef.h"
 #include "llvm/Frontend/OpenMP/OMPIRBuilder.h"
 #include "llvm/IR/DataLayout.h"
 #include "llvm/IR/Dominators.h"
@@ -45,14 +48,294 @@
 #include "llvm/IR/Intrinsics.h"
 #include "llvm/IR/MDBuilder.h"
 #include "llvm/Support/CRC.h"
+#include "llvm/Support/Casting.h"
 #include "llvm/Support/xxhash.h"
 #include "llvm/Transforms/Scalar/LowerExpectIntrinsic.h"
 #include "llvm/Transforms/Utils/PromoteMemToReg.h"
 #include <optional>
+#include <string>
 
 using namespace clang;
 using namespace CodeGen;
 
+namespace {
+  // Copied from: llvm-project/clang/lib/CodeGen/CGCall.cpp
+  // SNIP - refer to full diff or the referenced file
+} // namespace
+
 namespace llvm {
 extern cl::opt<bool> EnableSingleByteCoverage;
 } // namespace llvm
@@ -1123,6 +1406,55 @@ void CodeGenFunction::StartFunction(GlobalDecl GD, QualType RetTy,
         getLLVMContext(), VScaleRange->first, VScaleRange->second));
   }
 
+  if (FD && (getLangOpts().CPlusPlus || getLangOpts().C11 || getLangOpts().C17 || getLangOpts().C23 || getLangOpts().C2y || getLangOpts().C99)) {
+    auto Metadata = FD->fetchIrMetadata();
+    for (auto&&[Key, Value] : Metadata ) {
+      Fn->addMetadata(Key, *llvm::MDNode::get(Fn->getContext(),
+      llvm::MDString::get(Fn->getContext(), Value)));
+    }
+    
+    // constructing a type info map:
+    ClangToLLVMArgMapping mapping(FD->getASTContext(), FnInfo);
+    constexpr char PRIM_SEP = ' ';
+    constexpr char GROUP_SEP = '#';
+    constexpr char IDX_SZ_SEP = '-';
+    
+    std::string AttrmapResult = std::to_string(mapping.totalIRArgs()) + PRIM_SEP + std::to_string(FnInfo.arg_size()) + PRIM_SEP;
+    // this may expose invalid entries but bettter to have all the information
+    size_t ArgMapIters = std::max((size_t)FnInfo.arg_size(), FD->param_size()); 
+    for (size_t i = 0; i < ArgMapIters; ++i) {
+      auto irArgs = mapping.getIRArgs(i);
+      
+      AttrmapResult += (std::to_string(irArgs.first) + IDX_SZ_SEP + std::to_string(irArgs.second));
+      if (i < ArgMapIters - 1) {
+        AttrmapResult += GROUP_SEP;
+      }
+
+      // e.g. "3 2 1-1#2-1"
+      // 3 LLVM IR args, 2 "real args", mapped to index 1 and 2 and of sizes 1 and 1
+      // or "2 2 0-1#1-1" 2 and 2 args
+      // the map includes this pointer!
+      // this ptr index is accounted for in the AST pass (+1 to all argument indicies if function is an instance member)
+    }
+
+    Fn->addMetadata("LLCAP-CLANG-LLVM-MAP-DATA", *llvm::MDNode::get(Fn->getContext(),
+    llvm::MDString::get(Fn->getContext(), AttrmapResult)));
+    
+    // PRSGD: "PaRSe GuiDe"
+    auto* Node = Fn->getParent()->getOrInsertNamedMetadata("LLCAP-CLANG-LLVM-MAP-PRSGD");
+    if (Node->getOperand(0) == nullptr) {
+      Node->addOperand(llvm::MDNode::get(Fn->getParent()->getContext(),
+      llvm::MDString::get(Fn->getParent()->getContext(), std::string() + PRIM_SEP + GROUP_SEP + IDX_SZ_SEP)));
+    }
+    
+    Node = Fn->getParent()->getOrInsertNamedMetadata("LLCAP-CLANG-LLVM-MAP-INVLD_IDX");
+    if (Node->getOperand(0) == nullptr) {
+      Node->addOperand(llvm::MDNode::get(Fn->getParent()->getContext(),
+      llvm::MDString::get(Fn->getParent()->getContext(), std::to_string(ClangToLLVMArgMapping::InvalidIndex))));
+    }
+
+  }
+
   llvm::BasicBlock *EntryBB = createBasicBlock("entry", CurFn);
 
   // Create a marker to make it easy to insert allocas into the entryblock

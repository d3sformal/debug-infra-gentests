import ch.usi.dag.dislreserver.remoteanalysis.RemoteAnalysis;
import ch.usi.dag.dislreserver.shadow.ShadowObject;
import cz.cuni.mff.d3s.autodebugger.model.common.trace.Trace;
import java.nio.file.Path;
import java.nio.file.Files;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

public class Collector extends RemoteAnalysis {
  static {
    System.out.println("*** COLLECTOR CLASS LOADED ***");
  }

  private final String messageFormat = "[%s]: %s";
  private final String processName = "Receiving process";
  private final String identifierMappingFilePath = "${PATH}";
  private final String traceFilePath = "${TRACE_PATH}";
  private final String traceMode = "${TRACE_MODE}";

  // Debug mode: set to true for verbose output, false for production
  private static final boolean DEBUG = true;

  private Trace trace;
  private Map<Integer, Object> collectedValues = new HashMap<>();
  private java.util.List<Map<Integer, Object>> allInvocations = new java.util.ArrayList<>();
  private Map<Integer, Object> currentInvocation = new HashMap<>();
  private int currentEventIndex = 0;

  public Collector() {
    System.out.println("*** COLLECTOR CONSTRUCTOR CALLED ***");
    try {
      System.out.println("*** COLLECTOR: identifierMappingFilePath = " + identifierMappingFilePath + " ***");
      System.out.println("*** COLLECTOR: traceFilePath = " + traceFilePath + " ***");

      System.out.println("*** COLLECTOR: About to initialize simple data structures ***");

      // Initialize simple data structures first (don't initialize Trace here)
      this.collectedValues = new HashMap<>();
      this.allInvocations = new java.util.ArrayList<>();
      this.currentInvocation = new HashMap<>();
      this.trace = null; // Will be created lazily in atExit

      System.out.println("*** COLLECTOR: Simple initialization completed ***");

      System.out.println("*** COLLECTOR: Constructor completed successfully ***");
    } catch (Exception e) {
      System.err.println("*** COLLECTOR: Constructor failed: " + e.getMessage() + " ***");
      e.printStackTrace();
    }
  }

  private void printPid() {
    System.out.println(String.format(messageFormat, processName, String.format("PID: %s", (long) ProcessHandle.current().pid())));
  }

  public void startEvent() {
    if ("temporal".equalsIgnoreCase(traceMode)) {
      currentEventIndex++;
    }
  }






  public void collectInt(final int slot, final int i) {
    printPid();
    System.out.println("*** COLLECTOR: collectInt called with slot=" + slot + ", value=" + i + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting int: %s", i)));

    // Always store in fallback storage (last values)
    collectedValues.put(slot, i);

    // Store in current invocation
    currentInvocation.put(slot, i);

    // Check if we have collected all parameters for this invocation
    // For naive mode, we expect to collect all parameters before completing the invocation
    if (isInvocationComplete()) {
      // Save the current invocation
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");

      // Reset for next invocation
      currentInvocation.clear();
    }

    // Also store in Trace if available
    if (trace != null) {
      trace.addIntValue(slot, i);
    }

    currentEventIndex++;
  }

  private boolean isInvocationComplete() {
    // For naive mode, we expect to collect all exportable values
    // PARAM_COUNT is substituted at instrumentation time with the actual count
    return currentInvocation.size() >= ${PARAM_COUNT};
  }


  public void collectByte(final int slot, final byte b) {
    printPid();
    System.out.println("*** COLLECTOR: collectByte called with slot=" + slot + ", value=" + b + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting byte: %s", b)));

    collectedValues.put(slot, b);
    currentInvocation.put(slot, b);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addByteValue(slot, b);
    }

    currentEventIndex++;
  }

  public void collectChar(final int slot, final char c) {
    printPid();
    System.out.println("*** COLLECTOR: collectChar called with slot=" + slot + ", value=" + c + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting char: %s", c)));

    collectedValues.put(slot, c);
    currentInvocation.put(slot, c);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addCharValue(slot, c);
    }

    currentEventIndex++;
  }

  public void collectShort(final int slot, final short s) {
    printPid();
    System.out.println("*** COLLECTOR: collectShort called with slot=" + slot + ", value=" + s + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting short: %s", s)));

    collectedValues.put(slot, s);
    currentInvocation.put(slot, s);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addShortValue(slot, s);
    }

    currentEventIndex++;
  }

  public void collectLong(final int slot, final long l) {
    printPid();
    System.out.println("*** COLLECTOR: collectLong called with slot=" + slot + ", value=" + l + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting long: %s", l)));

    collectedValues.put(slot, l);
    currentInvocation.put(slot, l);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addLongValue(slot, l);
    }

    currentEventIndex++;
  }

  public void collectFloat(final int slot, final float f) {
    printPid();
    System.out.println("*** COLLECTOR: collectFloat called with slot=" + slot + ", value=" + f + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting float: %s", f)));

    collectedValues.put(slot, f);
    currentInvocation.put(slot, f);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addFloatValue(slot, f);
    }

    currentEventIndex++;
  }

  public void collectBoolean(final int slot, final boolean z) {
    printPid();
    System.out.println("*** COLLECTOR: collectBoolean called with slot=" + slot + ", value=" + z + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting boolean: %s", z)));

    collectedValues.put(slot, z);
    currentInvocation.put(slot, z);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addBooleanValue(slot, z);
    }

    currentEventIndex++;
  }

  public void collectString(final int slot, final Object s) {
    printPid();
    System.out.println("*** COLLECTOR: collectString called with slot=" + slot + ", value=" + s + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting string: %s", s)));

    collectedValues.put(slot, s);
    currentInvocation.put(slot, s);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    currentEventIndex++;
  }

  public void collectDouble(final int slot, final double d) {
    printPid();
    System.out.println("*** COLLECTOR: collectDouble called with slot=" + slot + ", value=" + d + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting double: %s", d)));

    collectedValues.put(slot, d);
    currentInvocation.put(slot, d);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addDoubleValue(slot, d);
    }

    currentEventIndex++;
  }

  public void collectObject(final int slot, final ShadowObject obj) {
    printPid();
    System.out.println("*** COLLECTOR: collectObject called with slot=" + slot + ", value=" + obj + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting object: %s", obj)));

    collectedValues.put(slot, obj);
    currentInvocation.put(slot, obj);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    currentEventIndex++;
  }

  @Override
  public void atExit() {
    System.out.println("*** COLLECTOR: atExit called ***");
    System.out.println(String.format(messageFormat, processName, "Exiting analysis..."));
    System.out.println(String.format(messageFormat, processName, "Collected " + allInvocations.size() + " invocations"));

    try {
      if (allInvocations.isEmpty()) {
        System.out.println(String.format(messageFormat, processName, "No values collected - writing empty trace"));
        // Still write an empty trace so callers know atExit ran but no data was collected
        Trace emptyTrace = new Trace();
        Path traceFile = Path.of(traceFilePath);
        Files.createDirectories(traceFile.getParent());
        try (java.io.FileOutputStream fileOutput = new java.io.FileOutputStream(traceFile.toFile());
             java.io.ObjectOutputStream objectStream = new java.io.ObjectOutputStream(fileOutput)) {
          objectStream.writeObject(emptyTrace);
        }
        System.out.println(String.format(messageFormat, processName, "Empty trace written to: " + traceFilePath));
        return;
      }

      // Print all invocations for debugging (only in DEBUG mode)
      if (DEBUG) {
        for (int i = 0; i < allInvocations.size(); i++) {
          Map<Integer, Object> invocation = allInvocations.get(i);
          System.out.println(String.format(messageFormat, processName, "Invocation " + (i + 1) + ":"));
          for (Map.Entry<Integer, Object> entry : invocation.entrySet()) {
            System.out.println(String.format(messageFormat, processName, "  Slot " + entry.getKey() + ": " + entry.getValue()));
          }
        }
      }

      // Build Trace from collected invocations
      System.out.println(String.format(messageFormat, processName, "Building trace from " + allInvocations.size() + " invocations"));
      Trace trace = buildTraceFromInvocations(allInvocations);

      // Serialize trace to traceFilePath
      System.out.println(String.format(messageFormat, processName, "Serializing trace to: " + traceFilePath));
      Path traceFile = Path.of(traceFilePath);
      Files.createDirectories(traceFile.getParent());

      try (java.io.FileOutputStream fileOutput = new java.io.FileOutputStream(traceFile.toFile());
           java.io.ObjectOutputStream objectStream = new java.io.ObjectOutputStream(fileOutput)) {
        objectStream.writeObject(trace);
      }

      System.out.println(String.format(messageFormat, processName, "Trace serialization complete"));

    } catch (Exception e) {
      System.err.println(String.format(messageFormat, processName, "Error during trace serialization: " + e.getMessage()));
      e.printStackTrace();
    }
  }



  /**
   * Builds a Trace object from the collected invocations.
   * Iterates through all invocations and adds values to the trace based on their type.
   */
  private Trace buildTraceFromInvocations(List<Map<Integer, Object>> invocations) {
    Trace trace = new Trace();

    for (Map<Integer, Object> invocation : invocations) {
      for (Map.Entry<Integer, Object> entry : invocation.entrySet()) {
        Object value = entry.getValue();
        int slot = entry.getKey();

        if (value instanceof Integer intValue) {
          trace.addIntValue(slot, intValue);
        } else if (value instanceof Byte byteValue) {
          trace.addByteValue(slot, byteValue);
        } else if (value instanceof Character charValue) {
          trace.addCharValue(slot, charValue);
        } else if (value instanceof Short shortValue) {
          trace.addShortValue(slot, shortValue);
        } else if (value instanceof Long longValue) {
          trace.addLongValue(slot, longValue);
        } else if (value instanceof Float floatValue) {
          trace.addFloatValue(slot, floatValue);
        } else if (value instanceof Double doubleValue) {
          trace.addDoubleValue(slot, doubleValue);
        } else if (value instanceof Boolean boolValue) {
          trace.addBooleanValue(slot, boolValue);
        }
      }
    }

    return trace;
  }



  @Override
  public void objectFree(ch.usi.dag.dislreserver.shadow.ShadowObject obj) {
    // Required implementation for RemoteAnalysis abstract method
    // This method is called when objects are freed by the garbage collector
    // For our use case, we don't need to do anything special here
  }
}


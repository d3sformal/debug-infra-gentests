import ch.usi.dag.dislreserver.remoteanalysis.RemoteAnalysis;
import ch.usi.dag.dislreserver.shadow.ShadowObject;
import cz.cuni.mff.d3s.autodebugger.model.common.trace.Trace;
import cz.cuni.mff.d3s.autodebugger.model.java.identifiers.JavaValueIdentifier;
import cz.cuni.mff.d3s.autodebugger.testgenerator.common.TestGenerationContext;
import cz.cuni.mff.d3s.autodebugger.testgenerator.common.TestGenerationContextFactory;
import cz.cuni.mff.d3s.autodebugger.testgenerator.common.TestGenerator;
import cz.cuni.mff.d3s.autodebugger.testgenerator.java.trace.NaiveTraceBasedGenerator;
import java.nio.file.Path;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

public class Collector extends RemoteAnalysis {
  static {
    System.out.println("*** COLLECTOR CLASS LOADED ***");
  }

  private final String messageFormat = "[%s]: %s";
  private final String processName = "Receiving process";
  private final String identifierMappingFilePath = "${PATH}";
  private final String resultsListPath = "${RESULTS}";
  private final String traceMode = "${TRACE_MODE}";
  private final String targetPackage = "${TARGET_PACKAGE}";
  private final String targetClass = "${TARGET_CLASS}";
  private final String targetMethod = "${TARGET_METHOD}";
  private final String targetReturn = "${TARGET_RETURN}";
  private final String strategyId = "${STRATEGY}";

  private Map<Integer, JavaValueIdentifier> identifierMapping;
  private Trace trace;
  private Map<Integer, Object> collectedValues = new HashMap<>(); // Fallback storage for last values
  private java.util.List<Map<Integer, Object>> allInvocations = new java.util.ArrayList<>(); // All method invocations
  private Map<Integer, Object> currentInvocation = new HashMap<>(); // Current method invocation being collected
  private int currentEventIndex = 0;

  public Collector() {
    System.out.println("*** COLLECTOR CONSTRUCTOR CALLED ***");
    try {
      System.out.println("*** COLLECTOR: identifierMappingFilePath = " + identifierMappingFilePath + " ***");
      System.out.println("*** COLLECTOR: resultsListPath = " + resultsListPath + " ***");

      System.out.println("*** COLLECTOR: About to initialize simple data structures ***");

      // Initialize simple data structures first (don't initialize Trace here)
      this.collectedValues = new HashMap<>();
      this.allInvocations = new java.util.ArrayList<>();
      this.currentInvocation = new HashMap<>();
      this.trace = null; // Will be created lazily in atExit
      this.identifierMapping = null; // Will be loaded lazily in atExit

      System.out.println("*** COLLECTOR: Simple initialization completed ***");

      System.out.println("*** COLLECTOR: Constructor completed successfully ***");
    } catch (Exception e) {
      System.err.println("*** COLLECTOR: Constructor failed: " + e.getMessage() + " ***");
      e.printStackTrace();
      // Initialize with defaults to prevent further failures
      this.identifierMapping = new HashMap<>();
    }
  }

  private void printPid() {
    System.out.println(String.format(messageFormat, processName, String.format("PID: %s", (long) ProcessHandle.current().pid())));
  }

  public void startEvent() {
    if ("temporal".equalsIgnoreCase(traceMode)) {
      currentEventIndex++;
    }
  }

  private Map<Integer, JavaValueIdentifier> loadIdentifierMapping(String path) {
    System.out.println("*** COLLECTOR: loadIdentifierMapping called with path = " + path + " ***");
    try {
      try (java.io.FileInputStream fileReader = new java.io.FileInputStream(java.nio.file.Path.of(path).toFile());
           java.io.ObjectInputStream objectStream = new java.io.ObjectInputStream(fileReader)) {
        @SuppressWarnings("unchecked")
        Map<Integer, JavaValueIdentifier> loaded = (HashMap<Integer, JavaValueIdentifier>) objectStream.readObject();
        System.out.println("*** COLLECTOR: Loaded identifier mapping with " + loaded.size() + " entries ***");
        return loaded;
      }
    } catch (Exception e) {
      System.err.println("*** COLLECTOR: Failed to load identifier mapping: " + e.getMessage() + " ***");
      return new HashMap<>();
    }
  }




  public void collectInt(final int slot, final int i) {
    printPid();
    System.out.println("*** COLLECTOR: collectInt called with slot=" + slot + ", value=" + i + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting int: %s", i)));

    // Always store in fallback storage (last values)
    collectedValues.put(slot, i);

    // Store in current invocation
    currentInvocation.put(slot, i);

    // Check if we have collected all parameters for this invocation
    // For naive mode, we expect to collect all parameters before completing the invocation
    if (isInvocationComplete()) {
      // Save the current invocation
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");

      // Reset for next invocation
      currentInvocation.clear();
    }

    // Also store in Trace if available
    if (trace != null) {
      trace.addIntValue(slot, i);
    }

    currentEventIndex++;
  }

  private boolean isInvocationComplete() {
    // For naive mode, we expect to collect all target parameters
    // We know we have 2 parameters (slots 1 and 2) for the add method
    return currentInvocation.size() >= 2;
  }


  public void collectByte(final int slot, final byte b) {
    printPid();
    System.out.println("*** COLLECTOR: collectByte called with slot=" + slot + ", value=" + b + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting byte: %s", b)));

    collectedValues.put(slot, b);
    currentInvocation.put(slot, b);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addByteValue(slot, b);
    }

    currentEventIndex++;
  }

  public void collectChar(final int slot, final char c) {
    printPid();
    System.out.println("*** COLLECTOR: collectChar called with slot=" + slot + ", value=" + c + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting char: %s", c)));

    collectedValues.put(slot, c);
    currentInvocation.put(slot, c);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addCharValue(slot, c);
    }

    currentEventIndex++;
  }

  public void collectShort(final int slot, final short s) {
    printPid();
    System.out.println("*** COLLECTOR: collectShort called with slot=" + slot + ", value=" + s + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting short: %s", s)));

    collectedValues.put(slot, s);
    currentInvocation.put(slot, s);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addShortValue(slot, s);
    }

    currentEventIndex++;
  }

  public void collectLong(final int slot, final long l) {
    printPid();
    System.out.println("*** COLLECTOR: collectLong called with slot=" + slot + ", value=" + l + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting long: %s", l)));

    collectedValues.put(slot, l);
    currentInvocation.put(slot, l);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addLongValue(slot, l);
    }

    currentEventIndex++;
  }

  public void collectFloat(final int slot, final float f) {
    printPid();
    System.out.println("*** COLLECTOR: collectFloat called with slot=" + slot + ", value=" + f + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting float: %s", f)));

    collectedValues.put(slot, f);
    currentInvocation.put(slot, f);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addFloatValue(slot, f);
    }

    currentEventIndex++;
  }

  public void collectBoolean(final int slot, final boolean z) {
    printPid();
    System.out.println("*** COLLECTOR: collectBoolean called with slot=" + slot + ", value=" + z + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting boolean: %s", z)));

    collectedValues.put(slot, z);
    currentInvocation.put(slot, z);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addBooleanValue(slot, z);
    }

    currentEventIndex++;
  }

  public void collectString(final int slot, final Object s) {
    printPid();
    System.out.println("*** COLLECTOR: collectString called with slot=" + slot + ", value=" + s + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting string: %s", s)));

    collectedValues.put(slot, s);
    currentInvocation.put(slot, s);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    currentEventIndex++;
  }

  public void collectDouble(final int slot, final double d) {
    printPid();
    System.out.println("*** COLLECTOR: collectDouble called with slot=" + slot + ", value=" + d + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting double: %s", d)));

    collectedValues.put(slot, d);
    currentInvocation.put(slot, d);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    if (trace != null) {
      trace.addDoubleValue(slot, d);
    }

    currentEventIndex++;
  }

  public void collectObject(final int slot, final ShadowObject obj) {
    printPid();
    System.out.println("*** COLLECTOR: collectObject called with slot=" + slot + ", value=" + obj + " ***");
    System.out.println(String.format(messageFormat, processName, String.format("Collecting object: %s", obj)));

    collectedValues.put(slot, obj);
    currentInvocation.put(slot, obj);

    if (isInvocationComplete()) {
      Map<Integer, Object> completedInvocation = new HashMap<>(currentInvocation);
      allInvocations.add(completedInvocation);
      System.out.println("*** COLLECTOR: Completed invocation " + allInvocations.size() + " with " + completedInvocation.size() + " parameters ***");
      currentInvocation.clear();
    }

    currentEventIndex++;
  }

  @Override
  public void atExit() {
    System.out.println("*** COLLECTOR: atExit called ***");
    System.out.println(String.format(messageFormat, processName, "Exiting analysis..."));
    System.out.println(String.format(messageFormat, processName, "Collected " + allInvocations.size() + " invocations"));

    try {
      if (allInvocations.isEmpty()) {
        System.out.println(String.format(messageFormat, processName, "No values collected"));
        return;
      }

      // Print all invocations for debugging
      for (int i = 0; i < allInvocations.size(); i++) {
        Map<Integer, Object> invocation = allInvocations.get(i);
        System.out.println(String.format(messageFormat, processName, "Invocation " + (i + 1) + ":"));
        for (Map.Entry<Integer, Object> entry : invocation.entrySet()) {
          System.out.println(String.format(messageFormat, processName, "  Slot " + entry.getKey() + ": " + entry.getValue()));
        }
      }

      // 1. Load identifier mapping
      System.out.println(String.format(messageFormat, processName, "Loading identifier mapping from: " + identifierMappingFilePath));
      identifierMapping = loadIdentifierMapping(identifierMappingFilePath);
      if (identifierMapping == null || identifierMapping.isEmpty()) {
        System.err.println(String.format(messageFormat, processName, "Failed to load identifier mapping - cannot generate tests"));
        return;
      }

      // 2. Build Trace from collected invocations
      System.out.println(String.format(messageFormat, processName, "Building trace from " + allInvocations.size() + " invocations"));
      Trace trace = buildTraceFromInvocations(allInvocations);

      // 3. Create test generation context
      System.out.println(String.format(messageFormat, processName, "Creating test generation context"));
      TestGenerationContext context = buildContext();

      // 4. Create appropriate test generator
      System.out.println(String.format(messageFormat, processName, "Creating test generator for strategy: " + strategyId));
      TestGenerator generator = createTestGenerator(strategyId, identifierMapping);

      // 5. Generate tests
      System.out.println(String.format(messageFormat, processName, "Generating tests..."));
      List<Path> generatedTestFiles = generator.generateTests(trace, context);
      System.out.println(String.format(messageFormat, processName, "Generated " + generatedTestFiles.size() + " test files"));

      // 6. Write test file paths to results list
      Path resultsFile = Path.of(resultsListPath);
      Files.createDirectories(resultsFile.getParent());

      for (Path testFile : generatedTestFiles) {
        Files.writeString(resultsFile,
            testFile.toAbsolutePath().toString() + System.lineSeparator(),
            StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        System.out.println(String.format(messageFormat, processName, "Wrote test file path: " + testFile.toAbsolutePath()));
      }

      System.out.println(String.format(messageFormat, processName, "Test generation complete"));

    } catch (Exception e) {
      System.err.println(String.format(messageFormat, processName, "Error during test generation: " + e.getMessage()));
      e.printStackTrace();
    }
  }

  private TestGenerationContext buildContext() {
    var outDir = Path.of(resultsListPath).getParent();
    return TestGenerationContextFactory.createFromStrings(
      targetPackage, targetClass, targetMethod, targetReturn, outDir);
  }

  /**
   * Builds a Trace object from the collected invocations.
   * Iterates through all invocations and adds values to the trace based on their type.
   */
  private Trace buildTraceFromInvocations(List<Map<Integer, Object>> invocations) {
    Trace trace = new Trace();

    for (Map<Integer, Object> invocation : invocations) {
      for (Map.Entry<Integer, Object> entry : invocation.entrySet()) {
        Object value = entry.getValue();
        int slot = entry.getKey();

        if (value instanceof Integer intValue) {
          trace.addIntValue(slot, intValue);
        } else if (value instanceof Byte byteValue) {
          trace.addByteValue(slot, byteValue);
        } else if (value instanceof Character charValue) {
          trace.addCharValue(slot, charValue);
        } else if (value instanceof Short shortValue) {
          trace.addShortValue(slot, shortValue);
        } else if (value instanceof Long longValue) {
          trace.addLongValue(slot, longValue);
        } else if (value instanceof Float floatValue) {
          trace.addFloatValue(slot, floatValue);
        } else if (value instanceof Double doubleValue) {
          trace.addDoubleValue(slot, doubleValue);
        } else if (value instanceof Boolean boolValue) {
          trace.addBooleanValue(slot, boolValue);
        }
      }
    }

    return trace;
  }

  /**
   * Creates the appropriate test generator based on the strategy ID.
   * Currently supports:
   * - "trace-based-naive": NaiveTraceBasedGenerator
   * Falls back to NaiveTraceBasedGenerator for unknown strategies.
   */
  private TestGenerator createTestGenerator(String strategy, Map<Integer, JavaValueIdentifier> mapping) {
    switch (strategy) {
      case "trace-based-naive":
        System.out.println(String.format(messageFormat, processName, "Creating NaiveTraceBasedGenerator"));
        return new NaiveTraceBasedGenerator(mapping);
      case "trace-based-temporal":
        // Future: return new TemporalTraceBasedGenerator(mapping);
        System.err.println(String.format(messageFormat, processName,
            "Temporal trace strategy not yet supported in Collector, falling back to naive"));
        return new NaiveTraceBasedGenerator(mapping);
      default:
        System.err.println(String.format(messageFormat, processName,
            "Unknown strategy: " + strategy + ", falling back to naive"));
        return new NaiveTraceBasedGenerator(mapping);
    }
  }

  @Override
  public void objectFree(ch.usi.dag.dislreserver.shadow.ShadowObject obj) {
    // Required implementation for RemoteAnalysis abstract method
    // This method is called when objects are freed by the garbage collector
    // For our use case, we don't need to do anything special here
  }
}


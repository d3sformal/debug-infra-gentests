import ch.usi.dag.dislreserver.remoteanalysis.RemoteAnalysis;
import ch.usi.dag.dislreserver.shadow.ShadowObject;
import ch.usi.dag.dislreserver.shadow.ShadowString;
import cz.cuni.mff.d3s.autodebugger.model.java.Trace;
import java.nio.file.Path;
import cz.cuni.mff.d3s.autodebugger.testgenerator.java.trace.NaiveTraceBasedGenerator;
import cz.cuni.mff.d3s.autodebugger.testgenerator.java.llm.LLMBasedTestGenerator;
import cz.cuni.mff.d3s.autodebugger.testgenerator.common.AnthropicClient;
import cz.cuni.mff.d3s.autodebugger.testgenerator.common.LLMConfiguration;
import cz.cuni.mff.d3s.autodebugger.testgenerator.java.llm.PromptBuilder;
import cz.cuni.mff.d3s.autodebugger.testgenerator.java.llm.CodeValidator;
// Note: The fields below (identifierMappingFilePath, resultsFilePath, targetPackage/targetClass/targetMethod, strategy)
// are compile-time injected by the instrumentor.
// The 'strategy' field determines which generator branch runs at analysis time; do not read it from system properties in this JVM.
// API keys are intentionally not baked in; the Collector reads them from environment variables (see analyzer-disl/README.md).
  // Optional context hints for generators
  private final String targetPackage = "${TARGET_PACKAGE}";
  private final String targetClass = "${TARGET_CLASS}";
  private final String targetMethod = "${TARGET_METHOD}";



public class Collector extends RemoteAnalysis {
  private final String messageFormat = "[%s]: %s";
  private final String processName = "Receiving process";
  private final String identifierMappingFilePath = "${PATH}";
  private final String resultsFilePath = "${RESULTS}";
  private final String strategy = "${STRATEGY}";

  private Trace trace = new Trace();

  public void collectByte(final int slot, final byte b) {
    printPid();
    trace.addByteValue(slot, b);
    System.out.println("Collected byte: " + b + " from slot: " + slot);
  }

  public void collectChar(final int slot, final char c) {
    printPid();
    trace.addCharValue(slot, c);
    System.out.println("Collected char: " + c + " from slot: " + slot);
  }

  public void collectShort(final int slot, final short s) {
    printPid();
    trace.addShortValue(slot, s);
    System.out.println("Collected short: " + s + " from slot: " + slot);
  }

  public void collectInt(final int slot, final int i) {
    printPid();
    trace.addIntValue(slot, i);
    System.out.println("Collected int: " + i + " from slot: " + slot);
  }

  public void collectLong(final int slot, final long l) {
    printPid();
    trace.addLongValue(slot, l);
    System.out.println("Collected long: " + l + " from slot: " + slot);
  }

  public void collectFloat(final int slot, final float f) {
    printPid();
    trace.addFloatValue(slot, f);
    System.out.println("Collected float: " + f + " from slot: " + slot);
  }

  public void collectDouble(final int slot, final double d) {
    printPid();
    trace.addDoubleValue(slot, d);
    System.out.println("Collected double: " + d + " from slot: " + slot);
  }

  public void collectBoolean(final int slot, final boolean z) {
    printPid();
    trace.addBooleanValue(slot, z);
    System.out.println("Collected boolean: " + z + " from slot: " + slot);
  }

  private void printPid() {
    System.out.println(
        String.format(messageFormat, processName, "PID: " + ProcessHandle.current().pid()));
  }

  @Override
  public void atExit() {
    System.out.println(String.format(messageFormat, processName, "Exiting analysis..."));
    trace.printSlotValues();

    try {
      java.util.List<java.nio.file.Path> testPaths;
      if ("ai-assisted".equals(strategy)) {
        var apiKey = System.getenv("ANTHROPIC_API_KEY");
        if (apiKey == null) { apiKey = System.getenv("OPENAI_API_KEY"); }
        if (apiKey == null) { apiKey = ""; }
        var llm = new LLMBasedTestGenerator(new AnthropicClient(), new PromptBuilder(), new CodeValidator());
        var config = LLMConfiguration.builder().apiKey(apiKey).modelName("claude-sonnet-4-20250514").maxTokens(4000).temperature(0.3).build();
        llm.configure(config);
        testPaths = llm.generateTests(trace);
      } else {
        var naive = new NaiveTraceBasedGenerator(Path.of(identifierMappingFilePath));
        testPaths = naive.generateTests(trace);
      }
      // Write generated test paths to results file for the main process to read
      java.nio.file.Path resultsPath = java.nio.file.Path.of(resultsFilePath);
      if (!java.nio.file.Files.exists(resultsPath.getParent())) {
        java.nio.file.Files.createDirectories(resultsPath.getParent());
      }
      java.nio.file.Files.write(
        resultsPath,
        testPaths.stream().map(java.nio.file.Path::toString).toList(),
        java.nio.file.StandardOpenOption.CREATE,
        java.nio.file.StandardOpenOption.TRUNCATE_EXISTING
      );
    } catch (Exception e) {
      System.err.println("Failed to generate tests in analysis process: " + e.getMessage());
      e.printStackTrace();
    }
  }

  @Override
  public void objectFree(final ShadowObject netRef) {
    System.out.println("Object free for id " + netRef.getId());
  }
}
